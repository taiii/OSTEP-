第六章 机制-受限制的直接执行 (Mechanism: Limited Direct Execution)


为了虚拟化CPU，OS需要让许多进程“同时”使用CPU。
思想很简单：让每个进程轮换使用CPU。
因为CPU执行指令非常快，因此每个进程看起来像是独占CPU。
难点有2个
1、由于OS需要切换进程使用CPU。切换的开销不能很大。
2、OS需要对CPU有控制权。当进程执行时，OS仍然可以获得CPU(可能是要切换进程，或者进程非法访问)。
为了实现这两点，通常需要OS和硬件共同支持(只有OS是不够的)。


基本的技术：“受限制的直接执行”
如果为了最大化进程的运行效率，可以“直接执行”(不受限制)
只需要让OS创建进程(细节在前一章)，然后把CPU交给进程。
进程不需要切换，不受OS控制。运行效率最高。
但同时也带来上面两个问题:
1、进程非法访问怎么办(可能访问了没有权限访问的文件)
2、进程一直运行怎么办(OS无法分配CPU给其他进程)
下面依次解决这两个问题。


问题1 限制进程操作
“直接执行”很快，但进程的操作不受限制
进程哪些操作要被限制？
IO请求 (磁盘，网络等) 
申请资源(申请CPU或内存)
但是进程需要这些操作，怎么办？
解决办法：引入“用户态”，“内核态”的概念
CPU可以处于“用户态”或“内核态”(需要硬件支持)
CPU执行进程代码时处于“用户态”，不能执行受限制操作。
CPU执行OS代码时处于“内核态”，操作不受限制。
那么，进程如何去执行受限制的操作呢？
简单来讲，进程只要告诉自己想要执行的受限制操作给OS，由OS代为执行就可以了。
这个操作叫做：“系统调用”(system call)
系统调用的细节？
进程通过“陷入”(trap)指令告诉硬件要执行系统调用
硬件把当前进程所使用的寄存器的值压入内核栈，将CPU置为内核态
并且通过陷入表(trap table)定位到要执行的OS代码，
代码执行完后，OS通过“从陷入返回”(return-from-trap)指令告诉硬件该系统调用执行完毕
硬件把刚才压入内核栈的值取出到寄存器，进入用户态，(通过PC寄存器)开始执行用户代码。



问题2 进程之间的切换
由于需要让进程共享CPU，OS需要调度进程，涉及到进程切换。
但是有一个问题，进程运行的时候，就意味着OS代码不在执行，OS怎样获取CPU？
一种OS和进程合作的方式：OS等待进程的系统调用或执行非法操作。
这样OS重新获取CPU，可以调度进程。
存在的问题是，如果进程是恶意代码，或者有BUG，一直执行占用CPU怎么办？
另一种方式，需要硬件配合，硬件使用定时器定时“陷入”(trap),
让OS重新获得CPU，就像系统调用一样。
进程切换的细节？
进程切换的一个重点是：假如进程A在执行，此时OS获得CPU(无论是通过定时器还是进程的系统调用)，
此时OS决定切换到进程B，然后“从陷入返回”(return-from-trap)。然后进程B就开始执行。
整个过程硬件只是完成它的工作，并不关心OS是否切换了进程。
具体来说：
当OS获得CPU后，如果决定切换进程
会保存OS寄存器的值到进程A内存中(进程寄存器的值已经被硬件保存到内核栈中)
然后从进程B内存恢复OS运行进程B时的OS寄存器值，此时切换到进程B内核栈。然后return-from-trap
此时硬件会从进程B的内核栈取值到寄存器。进程B开始执行。



