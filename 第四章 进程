第四章 进程：一种抽象

进程的定义：运行中的程序
一般会同时运行很多程序。
运行一个程序不用关注CPU是否可用，因为OS提供了CPU的虚拟化。尽管只有一个或几个CPU，OS让你看起来有许许多多CPU。
为了实现CPU虚拟化。我们需要一些低层次的“机制(mechanisms)”和高层次上的“策略(policies)”。
“机制”，比如说上下文切换，使OS有能力打断运行中的程序，切换到另一个程序。
“策略”，是一些让OS做决定的算法。给OS一些程序，哪一个程序先执行？调度策略会根据程序的历史信息，开销等做决定。

进程包括哪些部分？
内存。运行中的程序要读的指令、数据都在内存，因此内存中进程可寻址的部分(叫做寻址空间)是进程的一部分。
寄存器。许多指令明确的要读或更新寄存器。
永久存储设备(比如磁盘)。程序可能会访问磁盘。因此文件的IO信息(比如进程已经打开的文件列表)是进程一部分。


进程API
OS调用进程的API操作进程。理解进程的API可以更好的理解进程的行为。
进程有哪些API？
创建。很明显进程需要被创建。双击一个程序，或在命令行执行一个命令，OS就开始创建进程。
销毁。一个进程，正常执行完，或执行过程中被用户杀掉，都需要被销毁。
等待。等待进程执行完。(这里不大理解)
其他控制。除了上面这些，OS可能会对进程有其他的控制行为。(比如暂停一个进程，一会儿再继续执行)
获取状态。比如进程执行了多长时间。进程现在的处于的状态。


创建进程
进程会被创建。先来看一下进程创建的细节。
OS是怎样让一个程序启动执行起来的？
一个可执行的程序，放在磁盘上面。
OS首先要做的，是将这段程序(包含代码和数据)加载到内存。具体的说是加载到进程的寻址空间。
以前的OS会将程序一次性加载到内存。现在的OS是“懒加载”，只加载需要的部分。具体细节在之后的内存虚拟化章节。
现在只需要知道，OS必须将一些程序的字节加载到内存。
现在程序已经加载到内存，可以执行程序了吗？不能
OS还要给进程分配栈内存。C语言用栈来管理局部变量，方法参数，返回值。
还会初始化栈，就是传入main()方法的参数，argc和argv数组。
OS还会给进程分配堆内存。堆用来存放动态分配的数据。
一开始堆很小，随着进程的执行，可能会向OS申请更多的堆内存。
OS初始化进程IO信息。在UNIX中，进程有3个默认的文件描述符。
分别是标准输入、标准输出、标准错误。会从终端读取输入，从屏幕打印输出。
最后，OS会让进程进入到main()，进入细节在下一章。
现在，OS把CPU的控制权交给进程，进程正式开始执行...


进程所处状态
现在大概知道进程是什么，进程如何被创建。
进程是处于OS的调度之中。可以猜测，在调度中，一个进程不会一直执行。
进程会处于哪些状态呢？
1 运行状态(Running):占用CPU，正在执行指令。
2 就绪状态(Ready):可以进入运行，但OS选择暂时不去运行它。
3 阻塞状态(Blocked):进程正在执行一些操作，不能进入运行。最常见的，IO操作正在读取磁盘。


OS数据结构
OS也是一段程序，有它自己的数据结构。
OS的数据结构包括哪些呢？可以猜测：
会有一个就绪进程和一个阻塞进程的进程列表。
能够知道当前哪个进程正在运行。
对于阻塞的进程，能够追踪到哪些阻塞进程的IO操作已经结束，可以进入就绪状态。
对于每一个进程，会有一个数据结构，该数据结构大概包括：
进程的可寻址空间的内存位置。
进程状态。
进程的寄存器的值。
当运行中的进程被OS切换状态时，进程所用的寄存器的值就会被保存到进程的内存中。
这就叫做上下文切换。之后还会具体学习。
除了上面提到的进程的三种状态。在实际中，还会有更多的进程状态。
比如初始状态，是进程正在创建中的状态。
结束状态(unix系统叫僵尸状态)，进程已经结束，但还未被OS清除。可以用来获取该进程的退出状态码。





