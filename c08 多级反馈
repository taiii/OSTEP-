调度：多级反馈队列  Multi-level Feedback Queue (MLFQ)

MLFQ优化两部分
第一，优化周转时间，也就是让短任务先执行
但不知道进程的任何信息，如何做到？
第二，优化响应时间。
但像RR这种调度算法对周转时间很不友好。
如何做到这两者？




MLFQ的基本规则
有几个不同的队列
每个队列有一个优先级
优先级高的队列任务先执行
一个队列中可能有多个任务，则这个队列中的任务用RR调度
就是下面两条规则：
规则1、任务A优先级 > 任务B优先级，A执行
规则2、任务A优先级 = 任务B优先级，AB使用RR调度
现在问题的关键是，如何给任务一个优先级？
MLFQ通过对任务的观察，变化的调整任务的优先级
假如一个任务不停的放弃CPU，等待从键盘的输入，MLFQ会使这个任务优先级高
假如一个任务一直占用CPU，MLFQ会使这个任务的优先级低一些
总之，MLFQ通过对任务之前行为的学习，对任务未来的行为做出判断


如何改变优先级
MLFQ如何改变任务的优先级?(也就是改变任务的队列)
记住两点
第一 和用户交互频繁的任务一般运行时间比较短，可能经常放弃CPU
第二 对长时间占用CPU的任务来说响应时间不是很重要
因此有下面的规则
规则3、任务刚到达时，优先级最高
规则4a、如果任务运行过程中用尽整个时间片，它的优先级降低一级
规则4b、如果任务在时间片用尽之前放弃CPU，则它的优先级不变
场景1 一个长时间占用CPU的任务
假设有3个队列(2 1 0 2优先级最高)
1、首先在最高优先级队列2，运行完一个时间片后，降低一级到1。
2、接着运行完一个时间片后，再降低一级到0。
3、然后在最低优先级队列被分时间片执行完。
场景2 一个长时间占用CPU的任务和一个短任务
假设短任务要执行两个时间片的时长，只占用CPU
1、首先在最高优先级队列2，运行完一个时间片后，降低一级到1。
2、接着运行完一个时间片后，再降低一级到0。
3、这时候短任务到达，由于短任务优先级是2，先执行一个时间片，降级到1
4、这时候短任务优先级还是比长任务高，执行一个时间片，短任务结束
5、最后长任务被分时间片执行完。
假设短任务要执行两个时间片的时长，并且频繁放弃CPU(小于一个时间片)
执行类似于上面，只不过短任务由于在一个时间片内放弃CPU，不会被降级。
现在的调度看起来像是SJF
目前的MLFQ有什么问题？
1、如果有太多的IO任务轮流占用CPU，那么长任务永远得不到运行("饥饿")
2、恶意用户可能会利用这个调度的特点，在用完时间片之前，执行一个无用的IO
这样就能独占CPU
3、任务的行为可能会变化。一个长时间占用CPU的任务也可能会变成交互型的任务。



提升优先级
规则5、每隔一段时间S，把所有的任务放到最高优先级队列
这个规则解决了两个问题。1和3
1、长任务被调整到最高优先级，会被执行（解决了长任务饥饿问题）
3、行为变化后也可以被当做正常的交互型任务调度
时间S的调整是一个问题
如果太长，长任务会饥饿
如果太短，交互型任务响应时间会变长


更好的调整优先级
现在剩下最后一个问题，恶意用户利用调度特点独占CPU
其实恶意用户的目的不是IO，而是利用IO独占CPU，那么他的时间更多地还是利用在CPU上面
因此改写4a和4b,更好的处理调整优先级的规则
规则4、只要一个任务在给定的队列用尽了时间片(不管多少次放弃CPU)，那么它会降低一级
这样的话，真正的交互型任务会在较高的优先级队列停留比较长的时间(由于每隔一段时间会提升
所有任务优先级，因此不用担心交互性任务一直降级)


MLFQ调优 和 其他事项
如何参数化这样一个调度器？
比如，有多少队列？
每个队列的时间片大小？
多长时间提升优先级以防止饥饿？
大部分的MLFQ实现中不同队列的时间片不同
高优先级的时间片短，低优先级的时间片长
Solaris 的MLFQ实现中，提供了一系列的表，供管理员配置
可以配置进程生命周期中的优先级，每个时间分片大小，多长时间提升优先级等等
默认有60个队列，
队列从高优先级到低优先级，时间分片从20ms增加到几百毫秒
每隔一秒提升优先级。
其他的MLFQ实现可能通过数学公式来调整。
另外，调度器还会有一些其他的特性
比如，最高优先级队列预留给OS使用，用户任务不能获取最高优先级队列。
一些系统会接受用户的“建议”(advice)去调整优先级

MLFQ保证了周转时间(类似SJF/STCF)
并且也对长时间占用CPU的任务比较公平。
基于这个原因，许多系统使用基于MLFQ的形式的调度器。
